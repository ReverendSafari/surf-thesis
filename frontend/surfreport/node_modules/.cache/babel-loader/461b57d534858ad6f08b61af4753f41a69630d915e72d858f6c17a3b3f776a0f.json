{"ast":null,"code":"import axios from 'axios';\nimport { getWaveQuality } from '../utils/waveGrading.js';\nimport GradeDisplay from './GradeDisplay.vue';\nexport default {\n  props: {\n    beach: {\n      type: Object,\n      required: true\n    }\n  },\n  data() {\n    return {\n      waveData: [],\n      closestWave: null,\n      waveGrade: '',\n      // This will store 'green', 'yellow', or 'red'\n      beachAngle: 0,\n      isSingleColumn: false // New property for layout control\n    };\n  },\n  components: {\n    GradeDisplay\n  },\n  computed: {\n    waveHeightRange() {\n      const height = this.closestWave ? this.closestWave.height : 0;\n      if (height < 1) return 'Flat';\n      if (height < 2) return '1-2 ft';\n      if (height < 3) return '2-3 ft';\n      if (height < 4) return '3-4 ft';\n      if (height < 6) return '4-6 ft';\n      return '6+ ft';\n    },\n    waveDirectionCardinal() {\n      if (!this.closestWave) return '';\n      return this.convertDegreesToCardinal(this.closestWave.direction);\n    },\n    waveTextColorClass() {\n      // Map grade to text color\n      return this.waveGrade === 'green' ? 'text-green-700' : this.waveGrade === 'yellow' ? 'text-yellow-700' : 'text-red-700';\n    }\n  },\n  methods: {\n    async fetchWaves() {\n      if (this.beach && this.beach.beach_name) {\n        try {\n          const response = await axios.get(`https://3k7dz8sjwk.execute-api.us-east-2.amazonaws.com/TestStage/waves/${this.beach.beach_name}`);\n          const waveData = JSON.parse(response.data.waves);\n          const closestTimeIndex = this.findClosestTimeIndex(waveData.hourly.time);\n          this.closestWave = {\n            time: waveData.hourly.time[closestTimeIndex],\n            height: waveData.hourly.wave_height[closestTimeIndex],\n            direction: waveData.hourly.wave_direction[closestTimeIndex],\n            period: waveData.hourly.wave_period[closestTimeIndex]\n          };\n          const beachResponse = await axios.get('https://3k7dz8sjwk.execute-api.us-east-2.amazonaws.com/TestStage/beaches');\n          const beachData = beachResponse.data.beaches.find(b => b.beach_name === this.beach.beach_name);\n          if (beachData) {\n            this.beachAngle = beachData.beach_angle;\n          }\n          this.waveGrade = getWaveQuality(this.closestWave.direction, 10,\n          // Example wind speed, replace with actual data if available\n          this.closestWave.period, this.beachAngle, this.closestWave.height);\n          this.checkOverflow(); // Check overflow after data is loaded\n        } catch (error) {\n          console.error('Error fetching wave or beach data:', error);\n        }\n      }\n    },\n    findClosestTimeIndex(times) {\n      const currentTime = new Date();\n      const timeDifferences = times.map(time => {\n        const waveTime = new Date(time);\n        return Math.abs(waveTime - currentTime);\n      });\n      return timeDifferences.indexOf(Math.min(...timeDifferences));\n    },\n    convertDegreesToCardinal(degrees) {\n      const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW', 'N'];\n      const index = Math.round(degrees % 360 / 22.5);\n      return directions[index];\n    },\n    checkOverflow() {\n      const container = this.$el.querySelector('.flex');\n      const isOverflowing = container.scrollWidth > container.clientWidth;\n      this.isSingleColumn = isOverflowing;\n    }\n  },\n  watch: {\n    beach: {\n      immediate: true,\n      handler() {\n        this.fetchWaves();\n      }\n    }\n  }\n};","map":{"version":3,"names":["axios","getWaveQuality","GradeDisplay","props","beach","type","Object","required","data","waveData","closestWave","waveGrade","beachAngle","isSingleColumn","components","computed","waveHeightRange","height","waveDirectionCardinal","convertDegreesToCardinal","direction","waveTextColorClass","methods","fetchWaves","beach_name","response","get","JSON","parse","waves","closestTimeIndex","findClosestTimeIndex","hourly","time","wave_height","wave_direction","period","wave_period","beachResponse","beachData","beaches","find","b","beach_angle","checkOverflow","error","console","times","currentTime","Date","timeDifferences","map","waveTime","Math","abs","indexOf","min","degrees","directions","index","round","container","$el","querySelector","isOverflowing","scrollWidth","clientWidth","watch","immediate","handler"],"sources":["/home/safari/thesis/frontend/surfreport/src/components/CurrentWaveComponent.vue"],"sourcesContent":["<template>\n  <div class=\"w-full max-w-3xl mx-auto\">\n    <!-- Title centered at the top -->\n    <h3 class=\"text-center text-lg font-semibold mb-6\">Current Wave</h3>\n\n    <!-- Content Container -->\n    <div\n      :class=\"[\n        'flex flex-wrap justify-between space-y-6',\n        isSingleColumn ? 'flex-col space-y-6' : 'space-x-6'\n      ]\"\n    >\n      <!-- Left Column: Wave Height and Period -->\n      <div class=\"flex flex-col w-full sm:w-1/2\">\n        <p class=\"text-gray-600\">Wave Height</p>\n        <p\n          :class=\"[waveTextColorClass, ' font-bold whitespace-nowrap']\"\n        >\n          {{ waveHeightRange }} ({{ closestWave ? closestWave.height : 'N/A' }} ft)\n        </p>\n\n        <p class=\"text-gray-600 mt-4\">Wave Period</p>\n        <p class=\"font-bold whitespace-nowrap\">\n          {{ closestWave ? closestWave.period : 'N/A' }} seconds\n        </p>\n      </div>\n\n      <!-- Right Column: Wave Direction and Quality Grade -->\n      <div class=\"flex flex-col w-full sm:w-1/2\">\n        <p class=\"text-gray-600\">Wave Direction</p>\n        <div class=\"flex items-center space-x-2\">\n          <!-- Box containing the rotated arrow -->\n          <div class=\"w-10 h-10 flex items-center justify-center bg-gray-100 rounded-md\">\n            <span v-if=\"closestWave\" :style=\"{ transform: 'rotate(' + closestWave.direction + 'deg)' }\" class=\"text-xl font-bold\">↑</span>\n            <span v-else>N/A</span>\n          </div>\n\n          <!-- Display the direction in cardinal format and degrees -->\n          <span v-if=\"closestWave\" class=\"text-lg font-bold whitespace-nowrap\">\n            ({{ waveDirectionCardinal }} - {{ closestWave.direction }}°)\n          </span>\n        </div>\n\n        <div class=\"mt-6\">\n          <p class=\"text-gray-600\">Surf Grade</p>\n          <GradeDisplay v-if=\"waveGrade\" :grade=\"waveGrade\" />\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios';\nimport { getWaveQuality } from '../utils/waveGrading.js';\nimport GradeDisplay from './GradeDisplay.vue';\n\nexport default {\n  props: {\n    beach: {\n      type: Object,\n      required: true,\n    },\n  },\n  data() {\n    return {\n      waveData: [],\n      closestWave: null,\n      waveGrade: '', // This will store 'green', 'yellow', or 'red'\n      beachAngle: 0,\n      isSingleColumn: false, // New property for layout control\n    };\n  },\n  components: {\n    GradeDisplay,\n  },\n  computed: {\n    waveHeightRange() {\n      const height = this.closestWave ? this.closestWave.height : 0;\n      if (height < 1) return 'Flat';\n      if (height < 2) return '1-2 ft';\n      if (height < 3) return '2-3 ft';\n      if (height < 4) return '3-4 ft';\n      if (height < 6) return '4-6 ft';\n      return '6+ ft';\n    },\n    waveDirectionCardinal() {\n      if (!this.closestWave) return '';\n      return this.convertDegreesToCardinal(this.closestWave.direction);\n    },\n    waveTextColorClass() {\n      // Map grade to text color\n      return this.waveGrade === 'green'\n        ? 'text-green-700'\n        : this.waveGrade === 'yellow'\n        ? 'text-yellow-700'\n        : 'text-red-700';\n    },\n  },\n  methods: {\n    async fetchWaves() {\n      if (this.beach && this.beach.beach_name) {\n        try {\n          const response = await axios.get(\n            `https://3k7dz8sjwk.execute-api.us-east-2.amazonaws.com/TestStage/waves/${this.beach.beach_name}`\n          );\n          const waveData = JSON.parse(response.data.waves);\n          const closestTimeIndex = this.findClosestTimeIndex(waveData.hourly.time);\n\n          this.closestWave = {\n            time: waveData.hourly.time[closestTimeIndex],\n            height: waveData.hourly.wave_height[closestTimeIndex],\n            direction: waveData.hourly.wave_direction[closestTimeIndex],\n            period: waveData.hourly.wave_period[closestTimeIndex],\n          };\n\n          const beachResponse = await axios.get(\n            'https://3k7dz8sjwk.execute-api.us-east-2.amazonaws.com/TestStage/beaches'\n          );\n          const beachData = beachResponse.data.beaches.find(\n            (b) => b.beach_name === this.beach.beach_name\n          );\n\n          if (beachData) {\n            this.beachAngle = beachData.beach_angle;\n          }\n\n          this.waveGrade = getWaveQuality(\n            this.closestWave.direction,\n            10, // Example wind speed, replace with actual data if available\n            this.closestWave.period,\n            this.beachAngle,\n            this.closestWave.height\n          );\n\n          this.checkOverflow(); // Check overflow after data is loaded\n        } catch (error) {\n          console.error('Error fetching wave or beach data:', error);\n        }\n      }\n    },\n    findClosestTimeIndex(times) {\n      const currentTime = new Date();\n      const timeDifferences = times.map((time) => {\n        const waveTime = new Date(time);\n        return Math.abs(waveTime - currentTime);\n      });\n      return timeDifferences.indexOf(Math.min(...timeDifferences));\n    },\n    convertDegreesToCardinal(degrees) {\n      const directions = [\n        'N',\n        'NNE',\n        'NE',\n        'ENE',\n        'E',\n        'ESE',\n        'SE',\n        'SSE',\n        'S',\n        'SSW',\n        'SW',\n        'WSW',\n        'W',\n        'WNW',\n        'NW',\n        'NNW',\n        'N',\n      ];\n      const index = Math.round((degrees % 360) / 22.5);\n      return directions[index];\n    },\n    checkOverflow() {\n      const container = this.$el.querySelector('.flex');\n      const isOverflowing = container.scrollWidth > container.clientWidth;\n      this.isSingleColumn = isOverflowing;\n    },\n  },\n  watch: {\n    beach: {\n      immediate: true,\n      handler() {\n        this.fetchWaves();\n      },\n    },\n  },\n};\n</script>\n\n<style scoped>\n@import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;700&display=swap');\n\n* {\n  font-family: 'Plus Jakarta Sans', sans-serif;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}