{"ast":null,"code":"import { createCommentVNode as _createCommentVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, toDisplayString as _toDisplayString, vModelSelect as _vModelSelect, withDirectives as _withDirectives, createElementVNode as _createElementVNode } from \"vue\";\nconst _hoisted_1 = {\n  class: \"flex justify-center mt-4\"\n};\nconst _hoisted_2 = [\"value\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createCommentVNode(\" Beach Dropdown \"), $data.beaches.length > 0 ? _withDirectives((_openBlock(), _createElementBlock(\"select\", {\n    key: 0,\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = $event => $data.selectedBeach = $event),\n    onChange: _cache[1] || (_cache[1] = (...args) => $options.updateBeach && $options.updateBeach(...args)),\n    class: \"bg-white text-gray-700 pl-4 pr-4 py-2 border rounded-lg shadow-md w-full max-w-xs focus:outline-none focus:ring-2 focus:ring-blue-500\"\n  }, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.beaches, beach => {\n    return _openBlock(), _createElementBlock(\"option\", {\n      key: beach.beach_name,\n      value: beach\n    }, _toDisplayString(beach.beach_name) + \" (\" + _toDisplayString(beach.town) + \") \", 9 /* TEXT, PROPS */, _hoisted_2);\n  }), 128 /* KEYED_FRAGMENT */))], 544 /* NEED_HYDRATION, NEED_PATCH */)), [[_vModelSelect, $data.selectedBeach]]) : (_openBlock(), _createElementBlock(_Fragment, {\n    key: 1\n  }, [_createCommentVNode(\" Fallback while loading \"), _cache[2] || (_cache[2] = _createElementVNode(\"div\", {\n    class: \"text-gray-700 text-sm text-center\"\n  }, \"Loading beaches...\", -1 /* HOISTED */))], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))]);\n}","map":{"version":3,"names":["class","_createElementBlock","_hoisted_1","_createCommentVNode","$data","beaches","length","key","_cache","$event","selectedBeach","onChange","args","$options","updateBeach","_Fragment","_renderList","beach","beach_name","value","_toDisplayString","town","_hoisted_2","_createElementVNode"],"sources":["/home/safari/thesis/frontend/surfreport/src/components/BeachSelector.vue"],"sourcesContent":["<template>\n  <div class=\"flex justify-center mt-4\">\n    <!-- Beach Dropdown -->\n    <select\n      v-if=\"beaches.length > 0\"\n      v-model=\"selectedBeach\"\n      @change=\"updateBeach\"\n      class=\"bg-white text-gray-700 pl-4 pr-4 py-2 border rounded-lg shadow-md w-full max-w-xs focus:outline-none focus:ring-2 focus:ring-blue-500\"\n    >\n      <option v-for=\"beach in beaches\" :key=\"beach.beach_name\" :value=\"beach\">\n        {{ beach.beach_name }} ({{ beach.town }})\n      </option>\n    </select>\n\n    <!-- Fallback while loading -->\n    <div v-else class=\"text-gray-700 text-sm text-center\">Loading beaches...</div>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios';\n\nexport default {\n  data() {\n    return {\n      beaches: [], // Holds the fetched beach data\n      selectedBeach: null, // Now this will hold the full beach object, not just the name\n    };\n  },\n  methods: {\n    // Fetch beaches from the API\n    async fetchBeaches() {\n      try {\n        const response = await axios.get('https://3k7dz8sjwk.execute-api.us-east-2.amazonaws.com/TestStage/beaches');\n        this.beaches = response.data.beaches;\n\n        if (this.beaches.length > 0) {\n          const queryBeachName = this.$route.query.beach;\n\n          // Match the query parameter with the beach list, or default to the first\n          const matchedBeach = this.beaches.find(beach => beach.beach_name === queryBeachName);\n          this.selectedBeach = matchedBeach || this.beaches[0];\n\n          this.updateBeach(); // Ensure the selected beach is emitted and the URL is updated\n        }\n      } catch (error) {\n        console.error('Error fetching beaches:', error);\n      }\n    },\n\n    // Emit the entire selected beach object to the parent component\n    updateBeach() {\n      if (this.selectedBeach) {\n        this.$emit('beachSelected', this.selectedBeach); // Emit the selected beach\n        this.$router.replace({ query: { beach: this.selectedBeach.beach_name } }); // Update the URL without reloading\n      }\n    },\n  },\n  mounted() {\n    // Fetch beaches when the component is mounted\n    this.fetchBeaches();\n  },\n};\n</script>\n\n<style scoped>\n/* Add optional margin for spacing */\n.mt-4 {\n  margin-top: 1rem;\n}\n</style>\n"],"mappings":";;EACOA,KAAK,EAAC;AAA0B;mBADvC;;uBACEC,mBAAA,CAeM,OAfNC,UAeM,GAdJC,mBAAA,oBAAuB,EAEfC,KAAA,CAAAC,OAAO,CAACC,MAAM,O,+BADtBL,mBAAA,CASS;IAZbM,GAAA;IAAA,uBAAAC,MAAA,QAAAA,MAAA,MAAAC,MAAA,IAKeL,KAAA,CAAAM,aAAa,GAAAD,MAAA;IACrBE,QAAM,EAAAH,MAAA,QAAAA,MAAA,UAAAI,IAAA,KAAEC,QAAA,CAAAC,WAAA,IAAAD,QAAA,CAAAC,WAAA,IAAAF,IAAA,CAAW;IACpBZ,KAAK,EAAC;yBAENC,mBAAA,CAESc,SAAA,QAXfC,WAAA,CAS8BZ,KAAA,CAAAC,OAAO,EAAhBY,KAAK;yBAApBhB,mBAAA,CAES;MAFyBM,GAAG,EAAEU,KAAK,CAACC,UAAU;MAAGC,KAAK,EAAEF;wBAC5DA,KAAK,CAACC,UAAU,IAAG,IAAE,GAAAE,gBAAA,CAAGH,KAAK,CAACI,IAAI,IAAG,IAC1C,uBAXNC,UAAA;4FAKelB,KAAA,CAAAM,aAAa,E,mBAUxBT,mBAAA,CAA8Ec,SAAA;IAflFR,GAAA;EAAA,IAcIJ,mBAAA,4BAA+B,E,0BAC/BoB,mBAAA,CAA8E;IAAlEvB,KAAK,EAAC;EAAmC,GAAC,oBAAkB,qB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}